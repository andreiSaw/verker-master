
axiomatic Padding {

  logic type padding
  
}

tag voidP = {
}

type voidP = [voidP]

tag charP = voidP with {
  int8 charM: 8;
}

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

axiomatic Strlen {

  predicate valid_str{L}(charP[..] s) =
  \at((\exists uint64 n_1;
        ((((s + (n_1 :> integer)).charM :> integer) == 0) &&
          \at((if (\at(0,L) <= \at(n_1,L)) then (((\offset_min(\at(s,L)) <=
                                                    \at(0,L)) &&
                                                   (\offset_max(\at(s,L)) >=
                                                     \at(n_1,L))) &&
                                                  (\forall integer __framac_tmp1;
                                                    (((\at(0,L) <=
                                                        __framac_tmp1) &&
                                                       (__framac_tmp1 <=
                                                         \at(n_1,L))) ==>
                                                      true))) else true),L))),L)
   
  lemma valid_str_shift1{L} :
  (_C_1 : (\forall charP[..] s_0;
            ((((s_0.charM :> integer) != 0) && valid_str{L}(s_0)) ==>
              valid_str{L}((s_0 + 1)))))
   
  logic uint64 strlen{L}(charP[..] s_1) =
  \at((if (((s_1 + 0).charM :> integer) == 0) then ((0 :> int32) :> uint64) else (
      ((((1 :> int32) :> uint64) :> integer) +
        (strlen{L}((s_1 + 1)) :> integer)) :> uint64)),L)
   
  lemma strlen_before_null{L} :
  (_C_2 : (\forall charP[..] s_2;
            (\forall integer i_1;
              (((valid_str{L}(s_2) && (0 <= i_1)) &&
                 (i_1 < (strlen{L}(s_2) :> integer))) ==>
                (((s_2 + i_1).charM :> integer) != 0)))))
   
  lemma strlen_at_null{L} :
  (_C_3 : (\forall charP[..] s_3;
            (valid_str{L}(s_3) ==>
              (((s_3 + (strlen{L}(s_3) :> integer)).charM :> integer) == 0))))
   
  lemma strlen_shift{L} :
  (_C_4 : (\forall charP[..] s_4;
            (\forall uint64 i_2;
              ((valid_str{L}(s_4) && (i_2 <= strlen{L}(s_4))) ==>
                ((strlen{L}((s_4 + (i_2 :> integer))) :> integer) ==
                  ((strlen{L}(s_4) :> integer) - (i_2 :> integer)))))))
   
  lemma strlen_shift_ex{L} :
  (_C_5 : (\forall charP[..] s_5;
            (\forall uint64 i_3;
              (((valid_str{L}(s_5) && (0 < (i_3 :> integer))) &&
                 (i_3 <= strlen{L}(s_5))) ==>
                (strlen{L}((s_5 + (i_3 :> integer))) < strlen{L}(s_5))))))
   
  lemma strlen_shift1{L} :
  (_C_6 : (\forall charP[..] s_6;
            ((valid_str{L}(s_6) && ((s_6.charM :> integer) != 0)) ==>
              ((strlen{L}(s_6) :> integer) ==
                (1 + (strlen{L}((s_6 + 1)) :> integer))))))
   
  lemma strlen_pointers{L} :
  (_C_7 : (\forall charP[..] s_7;
            (\forall charP[..] sc;
              (((((valid_str{L}(s_7) && valid_str{L}(sc)) &&
                   (\base_block(s_7) == \base_block(sc))) &&
                  ((\base_block(s_7) == \base_block(sc)) &&
                    ((s_7 - sc) <= 0))) &&
                 (\forall integer i_4;
                   (((0 <= i_4) && (i_4 <= (sc - s_7))) ==>
                     (((s_7 + i_4).charM :> integer) != 0)))) ==>
                (strlen{L}(sc) <= strlen{L}(s_7))))))
   
  lemma strlen_main{L} :
  (_C_8 : (\forall charP[..] s_8;
            (\forall uint64 n_2;
              (((valid_str{L}(s_8) &&
                  (((s_8 + (n_2 :> integer)).charM :> integer) == 0)) &&
                 (\forall uint64 i_5;
                   ((i_5 < n_2) ==>
                     (((s_8 + (i_5 :> integer)).charM :> integer) != 0)))) ==>
                (strlen{L}(s_8) == n_2)))))
  
}

uint64 strlen(charP[..] s_0)
  requires (_C_30 : valid_str{Here}(s_0));
behavior default:
  assigns \nothing;
  ensures (_C_29 : (\result == strlen{Here}(\at(s_0,Old))));
{  
   (var charP[..] sc);
   
   (var uint64 __retres);
   
   {  (_C_9 : (sc = s_0));
      
      loop 
      behavior default:
        invariant (_C_20 : (\base_block(s_0) == \base_block(sc)));
      behavior default:
        invariant (_C_13 : (((_C_15 : (\base_block(s_0) == \base_block(sc))) &&
                              (_C_16 : ((s_0 - sc) <= 0))) &&
                             ((_C_18 : (\base_block(sc) ==
                                         \base_block((s_0 +
                                                       (strlen{Here}(
                                                       s_0) :> integer))))) &&
                               (_C_19 : ((sc -
                                           (s_0 +
                                             (strlen{Here}(s_0) :> integer))) <=
                                          0)))));
      behavior default:
        invariant (_C_12 : valid_str{Here}(sc));
      behavior default:
        invariant (_C_11 : ((strlen{Here}(s_0) :> integer) ==
                             ((strlen{Here}(sc) :> integer) + (sc - s_0))));
      variant (_C_10 : ((strlen{Here}(s_0) :> integer) - (sc - s_0)));
      while (true)
      {  
         {  (if (_C_23 : ((_C_22 : ((_C_21 : sc.charM) :> int32)) !=
                           (0 :> int32))) then () else 
            (goto while_0_break));
            (_C_25 : (sc = (_C_24 : (sc + (1 :> int32)))))
         }
      };
      (while_0_break : ());
      (_C_28 : (__retres = (_C_27 : ((_C_26 : (sc - s_0)) :> uint64))));
      
      (return __retres)
   }
}
