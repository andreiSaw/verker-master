
axiomatic Padding {

  logic type padding
  
}

tag voidP = {
}

type voidP = [voidP]

tag charP = voidP with {
  int8 charM: 8;
}

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

axiomatic Strlen {

  predicate valid_str{L}(charP[..] s) =
  \at((\exists uint64 n_1;
        ((((s + (n_1 :> integer)).charM :> integer) == 0) &&
          \at((if (\at(0,L) <= \at(n_1,L)) then (((\offset_min(\at(s,L)) <=
                                                    \at(0,L)) &&
                                                   (\offset_max(\at(s,L)) >=
                                                     \at(n_1,L))) &&
                                                  (\forall integer __framac_tmp1;
                                                    (((\at(0,L) <=
                                                        __framac_tmp1) &&
                                                       (__framac_tmp1 <=
                                                         \at(n_1,L))) ==>
                                                      true))) else true),L))),L)
   
  lemma valid_str_shift1{L} :
  (_C_1 : (\forall charP[..] s_0;
            ((((s_0.charM :> integer) != 0) && valid_str{L}(s_0)) ==>
              valid_str{L}((s_0 + 1)))))
   
  logic uint64 strlen{L}(charP[..] s_1) =
  \at((if (((s_1 + 0).charM :> integer) == 0) then ((0 :> int32) :> uint64) else (
      ((((1 :> int32) :> uint64) :> integer) +
        (strlen{L}((s_1 + 1)) :> integer)) :> uint64)),L)
   
  lemma strlen_before_null{L} :
  (_C_2 : (\forall charP[..] s_2;
            (\forall integer i_1;
              (((valid_str{L}(s_2) && (0 <= i_1)) &&
                 (i_1 < (strlen{L}(s_2) :> integer))) ==>
                (((s_2 + i_1).charM :> integer) != 0)))))
   
  lemma strlen_at_null{L} :
  (_C_3 : (\forall charP[..] s_3;
            (valid_str{L}(s_3) ==>
              (((s_3 + (strlen{L}(s_3) :> integer)).charM :> integer) == 0))))
   
  lemma strlen_shift{L} :
  (_C_4 : (\forall charP[..] s_4;
            (\forall uint64 i_2;
              ((valid_str{L}(s_4) && (i_2 <= strlen{L}(s_4))) ==>
                ((strlen{L}((s_4 + (i_2 :> integer))) :> integer) ==
                  ((strlen{L}(s_4) :> integer) - (i_2 :> integer)))))))
   
  lemma strlen_shift_ex{L} :
  (_C_5 : (\forall charP[..] s_5;
            (\forall uint64 i_3;
              (((valid_str{L}(s_5) && (0 < (i_3 :> integer))) &&
                 (i_3 <= strlen{L}(s_5))) ==>
                (strlen{L}((s_5 + (i_3 :> integer))) < strlen{L}(s_5))))))
   
  lemma strlen_shift1{L} :
  (_C_6 : (\forall charP[..] s_6;
            ((valid_str{L}(s_6) && ((s_6.charM :> integer) != 0)) ==>
              ((strlen{L}(s_6) :> integer) ==
                (1 + (strlen{L}((s_6 + 1)) :> integer))))))
   
  lemma strlen_pointers{L} :
  (_C_7 : (\forall charP[..] s_7;
            (\forall charP[..] sc;
              (((((valid_str{L}(s_7) && valid_str{L}(sc)) &&
                   (\base_block(s_7) == \base_block(sc))) &&
                  ((\base_block(s_7) == \base_block(sc)) &&
                    ((s_7 - sc) <= 0))) &&
                 (\forall integer i_4;
                   (((0 <= i_4) && (i_4 <= (sc - s_7))) ==>
                     (((s_7 + i_4).charM :> integer) != 0)))) ==>
                (strlen{L}(sc) <= strlen{L}(s_7))))))
   
  lemma strlen_main{L} :
  (_C_8 : (\forall charP[..] s_8;
            (\forall uint64 n_2;
              (((valid_str{L}(s_8) &&
                  (((s_8 + (n_2 :> integer)).charM :> integer) == 0)) &&
                 (\forall uint64 i_5;
                   ((i_5 < n_2) ==>
                     (((s_8 + (i_5 :> integer)).charM :> integer) != 0)))) ==>
                (strlen{L}(s_8) == n_2)))))
   
  logic boolean in_array{L}(charP[..] s_9, int8 val) =
  \at((if ((s_9.charM :> integer) == 0) then false else (if (s_9.charM ==
                                                              val) then true else in_array{L}(
                                                        (s_9 + 1), val))),L)
   
  lemma in_array_shift1{L} :
  (_C_9 : (\forall charP[..] s_10;
            (\forall int8 val_0;
              ((((valid_str{L}(s_10) && ((s_10.charM :> integer) != 0)) &&
                  (s_10.charM != val_0)) &&
                 ((val_0 :> integer) != 0)) ==>
                (in_array{L}(s_10, val_0) == in_array{L}((s_10 + 1), val_0))))))
   
  lemma in_array_at_null{L} :
  (_C_10 : (\forall charP[..] s_11;
             (\forall int8 val_1;
               ((((s_11.charM :> integer) == 0) && ((val_1 :> integer) != 0)) ==>
                 (in_array{L}(s_11, val_1) == false)))))
   
  lemma in_array_shift2{L} :
  (_C_11 : (\forall charP[..] s_12;
             (\forall int8 val_2;
               ((((valid_str{L}(s_12) && ((s_12.charM :> integer) != 0)) &&
                   (s_12.charM == val_2)) &&
                  ((val_2 :> integer) != 0)) ==>
                 (in_array{L}(s_12, val_2) == true)))))
   
  logic uint64 strspn(charP[..] s_13, charP[..] accept)
   
  lemma strspn_shift{L} :
  (_C_12 : (\forall charP[..] s_14;
             (\forall charP[..] accept_0;
               ((((valid_str{L}(s_14) && valid_str{L}(accept_0)) &&
                   ((s_14.charM :> integer) != 0)) &&
                  (in_array{L}(accept_0, s_14.charM) == true)) ==>
                 ((strspn(s_14, accept_0) :> integer) ==
                   ((((1 :> int32) :> uint64) :> integer) +
                     (strspn((s_14 + 1), accept_0) :> integer)))))))
   
  lemma strspn_s_null{L} :
  (_C_13 : (\forall charP[..] s_15;
             (\forall charP[..] accept_1;
               (((s_15.charM :> integer) == 0) ==>
                 (strspn(s_15, accept_1) == ((0 :> int32) :> uint64))))))
   
  lemma strspn_accept_null{L} :
  (_C_14 : (\forall charP[..] s_16;
             (\forall charP[..] accept_2;
               (((accept_2.charM :> integer) == 0) ==>
                 (strspn(s_16, accept_2) == ((0 :> int32) :> uint64))))))
   
  lemma strspn_shift2{L} :
  (_C_15 : (\forall charP[..] s_17;
             (\forall charP[..] accept_3;
               ((((valid_str{L}(s_17) && valid_str{L}(accept_3)) &&
                   ((s_17.charM :> integer) != 0)) &&
                  (! (in_array{L}(accept_3, s_17.charM) == true))) ==>
                 (strspn(s_17, accept_3) == strspn((s_17 + 1), accept_3))))))
   
  lemma strspn_shift3{L} :
  (_C_16 : (\forall charP[..] s_18;
             (\forall charP[..] accept_4;
               ((((valid_str{L}(s_18) && valid_str{L}(accept_4)) &&
                   ((s_18.charM :> integer) == 0)) &&
                  (in_array{L}(accept_4, s_18.charM) == true)) ==>
                 (strspn(s_18, accept_4) == ((0 :> int32) :> uint64))))))
   
  lemma strspn_range{L} :
  (_C_17 : (\forall charP[..] s_19;
             (\forall charP[..] accept_5;
               (\forall uint64 cnt;
                 (((valid_str{L}(s_19) && valid_str{L}(accept_5)) &&
                    (strspn(s_19, accept_5) == cnt)) ==>
                   ((0 <= (strspn(s_19, accept_5) :> integer)) &&
                     (strspn(s_19, accept_5) <= cnt)))))))
   
  lemma strspn_pointers{L} :
  (_C_18 : (\forall charP[..] s_20;
             (\forall charP[..] sc_0;
               (\forall charP[..] accept_6;
                 (((((valid_str{L}(s_20) && valid_str{L}(sc_0)) &&
                      (\base_block(s_20) == \base_block(sc_0))) &&
                     ((\base_block(s_20) == \base_block(sc_0)) &&
                       ((s_20 - sc_0) <= 0))) &&
                    ((\base_block(sc_0) ==
                       \base_block((s_20 + (strlen{L}(s_20) :> integer)))) &&
                      ((sc_0 - (s_20 + (strlen{L}(s_20) :> integer))) < 0))) ==>
                   (strspn(sc_0, accept_6) <= strspn(s_20, accept_6)))))))
   
  lemma strspn_all_chars{L} :
  (_C_19 : (\forall charP[..] s_21;
             (\forall charP[..] accept_7;
               (\forall charP[..] sc_1;
                 ((((((valid_str{L}(s_21) && valid_str{L}(accept_7)) &&
                       ((s_21.charM :> integer) != 0)) &&
                      ((\base_block(s_21) == \base_block(sc_1)) &&
                        ((s_21 - sc_1) <= 0))) &&
                     ((\base_block(sc_1) ==
                        \base_block((s_21 + (strlen{L}(s_21) :> integer)))) &&
                       ((sc_1 - (s_21 + (strlen{L}(s_21) :> integer))) < 0))) &&
                    (\forall charP[..] t;
                      ((((\base_block(accept_7) == \base_block(t)) &&
                          ((accept_7 - t) <= 0)) &&
                         ((\base_block(t) ==
                            \base_block((accept_7 +
                                          (strlen{L}(accept_7) :> integer)))) &&
                           ((t -
                              (accept_7 + (strlen{L}(accept_7) :> integer))) <
                             0))) ==>
                        (sc_1.charM == t.charM)))) ==>
                   (strspn(s_21, accept_7) == strlen{L}(s_21)))))))
   
  lemma strspn_less{L} :
  (_C_20 : (\forall charP[..] s_22;
             (\forall charP[..] accept_8;
               (((valid_str{L}(s_22) && valid_str{L}(accept_8)) &&
                  ((s_22.charM :> integer) != 0)) ==>
                 (strspn(s_22, accept_8) <= strlen{L}(s_22))))))
  
}

uint64 strspn(charP[..] s, charP[..] accept)
  requires (_C_74 : ((_C_75 : valid_str{Here}(s)) &&
                      (_C_76 : valid_str{Here}(accept))));
behavior default:
  assigns \nothing;
  ensures (_C_69 : (((_C_71 : (0 <= (\result :> integer))) &&
                      (_C_72 : (\result <= strlen{Here}(\at(s,Old))))) &&
                     (_C_73 : (\forall charP[..] z_0;
                                ((((\base_block(\at(s,Old)) ==
                                     \base_block(z_0)) &&
                                    ((\at(s,Old) - z_0) <= 0)) &&
                                   ((\base_block(z_0) ==
                                      \base_block((\at(s,Old) +
                                                    (strlen{Here}(\at(s,Old)) :> integer)))) &&
                                     ((z_0 -
                                        (\at(s,Old) +
                                          (strlen{Here}(\at(s,Old)) :> integer))) <
                                       0))) ==>
                                  (\exists charP[..] t_2;
                                    ((((\base_block(\at(accept,Old)) ==
                                         \base_block(t_2)) &&
                                        ((\at(accept,Old) - t_2) <= 0)) &&
                                       ((\base_block(t_2) ==
                                          \base_block((\at(accept,Old) +
                                                        (strlen{Here}(
                                                        \at(accept,Old)) :> integer)))) &&
                                         ((t_2 -
                                            (\at(accept,Old) +
                                              (strlen{Here}(\at(accept,Old)) :> integer))) <
                                           0))) &&
                                      (z_0.charM == t_2.charM))))))));
{  
   (var charP[..] p);
   
   (var charP[..] a);
   
   (var uint64 count);
   
   (var uint64 __retres);
   
   {  (_C_21 : (count = (0 :> uint64)));
      (_C_22 : (p = s));
      
      loop 
      behavior default:
        invariant (_C_29 : (((_C_31 : (\base_block(s) == \base_block(p))) &&
                              (_C_32 : ((s - p) <= 0))) &&
                             ((_C_34 : (\base_block(p) ==
                                         \base_block((s +
                                                       (strlen{Here}(
                                                       s) :> integer))))) &&
                               (_C_35 : ((p -
                                           (s + (strlen{Here}(s) :> integer))) <=
                                          0)))));
      behavior default:
        invariant (_C_26 : ((_C_27 : (0 <= (count :> integer))) &&
                             (_C_28 : (count <= strlen{Here}(s)))));
      behavior default:
        invariant (_C_25 : ((count :> integer) == (p - s)));
      behavior default:
        invariant (_C_24 : (\forall charP[..] z;
                             ((((\base_block(s) == \base_block(z)) &&
                                 ((s - z) <= 0)) &&
                                ((\base_block(z) == \base_block(p)) &&
                                  ((z - p) < 0))) ==>
                               (\exists charP[..] t_1;
                                 ((((\base_block(accept) == \base_block(t_1)) &&
                                     ((accept - t_1) <= 0)) &&
                                    ((\base_block(t_1) ==
                                       \base_block((accept +
                                                     (strlen{Here}(accept) :> integer)))) &&
                                      ((t_1 -
                                         (accept +
                                           (strlen{Here}(accept) :> integer))) <
                                        0))) &&
                                   (z.charM == t_1.charM))))));
      variant (_C_23 : ((strlen{Here}(s) :> integer) - (p - s)));
      while (true)
      {  
         {  (if (_C_38 : ((_C_37 : ((_C_36 : p.charM) :> int32)) !=
                           (0 :> int32))) then () else 
            (goto while_0_break));
            
            {  (_C_39 : (a = accept));
               
               loop 
               behavior default:
                 invariant (_C_42 : (((_C_44 : (\base_block(accept) ==
                                                 \base_block(a))) &&
                                       (_C_45 : ((accept - a) <= 0))) &&
                                      ((_C_47 : (\base_block(a) ==
                                                  \base_block((accept +
                                                                (strlen{Here}(
                                                                accept) :> integer))))) &&
                                        (_C_48 : ((a -
                                                    (accept +
                                                      (strlen{Here}(accept) :> integer))) <=
                                                   0)))));
               behavior default:
                 invariant (_C_41 : (\forall charP[..] t_0;
                                      ((((\base_block(accept) ==
                                           \base_block(t_0)) &&
                                          ((accept - t_0) <= 0)) &&
                                         ((\base_block(t_0) ==
                                            \base_block(a)) &&
                                           ((t_0 - a) < 0))) ==>
                                        (p.charM != t_0.charM))));
               variant (_C_40 : ((strlen{Here}(accept) :> integer) -
                                  (a - accept)));
               while (true)
               {  
                  {  (if (_C_51 : ((_C_50 : ((_C_49 : a.charM) :> int32)) !=
                                    (0 :> int32))) then () else 
                     (goto while_1_break));
                     
                     {  (if (_C_56 : ((_C_55 : ((_C_54 : p.charM) :> int32)) ==
                                       (_C_53 : ((_C_52 : a.charM) :> int32)))) then 
                        (goto while_1_break) else ())
                     };
                     (_C_58 : (a = (_C_57 : (a + (1 :> int32)))))
                  }
               };
               (while_1_break : ());
               (if (_C_62 : ((_C_61 : ((_C_60 : a.charM) :> int32)) ==
                              (0 :> int32))) then 
               {  (_C_59 : (__retres = count));
                  
                  (goto return_label)
               } else ());
               (_C_65 : (count = (_C_64 : ((_C_63 : (count + (1 :> uint64))) :> uint64))))
            };
            (_C_67 : (p = (_C_66 : (p + (1 :> int32)))))
         }
      };
      (while_0_break : ());
      (_C_68 : (__retres = count));
      (return_label : 
      (return __retres))
   }
}
