
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_safe

  use why3.Bool.Bool 
  
end

module Root_unsigned_charP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Strlen

  use Uint64_of_Int32 
  
  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      (((=)
       (Int8.to_int
       (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))) (0))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  lemma Valid_str_shift1
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 12 7 83#
  "expl:Lemma valid_str_shift1" :
  (forall voidP_s_0_7_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_0_7_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 12 7 83#
    (forall s_0_0 : (pointer voidP).
     ((((<>) (Int8.to_int (select charP_charM_s_0_7_at_L s_0_0)) (0)) /\
      (valid_str s_0_0 voidP_s_0_7_alloc_table_at_L charP_charM_s_0_7_at_L))
      ->
      (valid_str (shift s_0_0 (1)) voidP_s_0_7_alloc_table_at_L
      charP_charM_s_0_7_at_L))))))
  
  function strlen (pointer voidP) (memory voidP Int8.t) :
  Uint64.t
  
  lemma Strlen_before_null
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 20 7 106#
  "expl:Lemma strlen_before_null" :
  (forall voidP_s_2_8_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_2_8_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 20 7 106#
    (forall s_2 : (pointer voidP).
     (forall i_1 : int.
      (((valid_str s_2 voidP_s_2_8_alloc_table_at_L charP_charM_s_2_8_at_L)
       /\
       (((<=) (0) i_1) /\
       ((<) i_1 (Uint64.to_int (strlen s_2 charP_charM_s_2_8_at_L))))) ->
       ((<>) (Int8.to_int (select charP_charM_s_2_8_at_L (shift s_2 i_1)))
       (0))))))))
  
  lemma Strlen_at_null
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 25 7 71#
  "expl:Lemma strlen_at_null" :
  (forall voidP_s_3_9_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_3_9_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 25 7 71#
    (forall s_3 : (pointer voidP).
     ((valid_str s_3 voidP_s_3_9_alloc_table_at_L charP_charM_s_3_9_at_L) ->
      ((=)
      (Int8.to_int
      (select charP_charM_s_3_9_at_L
      (shift s_3 (Uint64.to_int (strlen s_3 charP_charM_s_3_9_at_L))))) (0)))))))
  
  lemma Strlen_shift
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 29 7 125#
  "expl:Lemma strlen_shift" :
  (forall voidP_s_4_10_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_4_10_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 29 7 125#
    (forall s_4 : (pointer voidP).
     (forall i_2 : Uint64.t.
      (((valid_str s_4 voidP_s_4_10_alloc_table_at_L charP_charM_s_4_10_at_L)
       /\ (Uint64.(<=) i_2 (strlen s_4 charP_charM_s_4_10_at_L))) ->
       ((=)
       (Uint64.to_int
       (strlen (shift s_4 (Uint64.to_int i_2)) charP_charM_s_4_10_at_L))
       (Int.(-) (Uint64.to_int (strlen s_4 charP_charM_s_4_10_at_L))
       (Uint64.to_int i_2)))))))))
  
  lemma Strlen_shift_ex
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 35 7 126#
  "expl:Lemma strlen_shift_ex" :
  (forall voidP_s_5_11_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_5_11_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 35 7 126#
    (forall s_5 : (pointer voidP).
     (forall i_3 : Uint64.t.
      (((valid_str s_5 voidP_s_5_11_alloc_table_at_L charP_charM_s_5_11_at_L)
       /\
       (((<) (0) (Uint64.to_int i_3)) /\
       (Uint64.(<=) i_3 (strlen s_5 charP_charM_s_5_11_at_L)))) ->
       (Uint64.(<)
       (strlen (shift s_5 (Uint64.to_int i_3)) charP_charM_s_5_11_at_L)
       (strlen s_5 charP_charM_s_5_11_at_L))))))))
  
  lemma Strlen_shift1
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 41 7 103#
  "expl:Lemma strlen_shift1" :
  (forall voidP_s_6_12_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_6_12_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 41 7 103#
    (forall s_6 : (pointer voidP).
     (((valid_str s_6 voidP_s_6_12_alloc_table_at_L charP_charM_s_6_12_at_L)
      /\ ((<>) (Int8.to_int (select charP_charM_s_6_12_at_L s_6)) (0))) ->
      ((=) (Uint64.to_int (strlen s_6 charP_charM_s_6_12_at_L))
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_6 (1)) charP_charM_s_6_12_at_L)))))))))
  
  lemma Strlen_pointers
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 46 7 253#
  "expl:Lemma strlen_pointers" :
  (forall voidP_s_7_13_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_7_13_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 46 7 253#
    (forall s_7 : (pointer voidP).
     (forall sc : (pointer voidP).
      (((valid_str s_7 voidP_s_7_13_alloc_table_at_L charP_charM_s_7_13_at_L)
       /\
       ((valid_str sc voidP_s_7_13_alloc_table_at_L charP_charM_s_7_13_at_L)
       /\
       ((same_block s_7 sc) /\
       ((same_block s_7 sc) /\
       (((<=) (sub_pointer s_7 sc) (0)) /\
       (forall i_4 : int.
        ((((<=) (0) i_4) /\ ((<=) i_4 (sub_pointer sc s_7))) ->
         ((<>) (Int8.to_int (select charP_charM_s_7_13_at_L (shift s_7 i_4)))
         (0))))))))) ->
       (Uint64.(<=) (strlen sc charP_charM_s_7_13_at_L)
       (strlen s_7 charP_charM_s_7_13_at_L))))))))
  
  lemma Strlen_main
  #"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 55 7 159#
  "expl:Lemma strlen_main" :
  (forall voidP_s_8_15_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_8_15_at_L : (memory voidP Int8.t).
    (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 55 7 159#
    (forall s_8 : (pointer voidP).
     (forall n_2 : Uint64.t.
      (((valid_str s_8 voidP_s_8_15_alloc_table_at_L charP_charM_s_8_15_at_L)
       /\
       (((=)
        (Int8.to_int
        (select charP_charM_s_8_15_at_L (shift s_8 (Uint64.to_int n_2))))
        (0))
       /\
       (forall i_5 : Uint64.t.
        ((Uint64.(<) i_5 n_2) ->
         ((<>)
         (Int8.to_int
         (select charP_charM_s_8_15_at_L (shift s_8 (Uint64.to_int i_5))))
         (0)))))) -> (Uint64.(=) (strlen s_8 charP_charM_s_8_15_at_L) n_2)))))))
  
  axiom Strlen_definition :
  (forall s_1 : (pointer voidP).
   (forall charP_charM_s_1_3_at_L : (memory voidP Int8.t)
    [(strlen s_1 charP_charM_s_1_3_at_L)] .
    ((=) (strlen s_1 charP_charM_s_1_3_at_L)
    (if
     ((=) (Int8.to_int (select charP_charM_s_1_3_at_L (shift s_1 (0)))) (0))
     then (#"strspn.jc" 45 51 75# "expl:Integer cast"
     (Uint64_of_Int32.cast (#"strspn.jc" 45 52 64# "expl:Integer cast"
     (Int32.of_int (0))))) else (#"strspn.jc" 45 81 183# "expl:Integer cast"
     (Uint64.of_int
     (Int.(+)
     (Uint64.to_int (#"strspn.jc" 46 8 32# "expl:Integer cast"
     (Uint64_of_Int32.cast (#"strspn.jc" 46 9 21# "expl:Integer cast"
     (Int32.of_int (1))))))
     (Uint64.to_int (strlen (shift s_1 (1)) charP_charM_s_1_3_at_L)))))))))
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Goto_while_1_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_strspn_safety

  use enum.Uint64 
  
  use Safe_uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strspn #"/Users/macbook/Documents/HSE/verker-master/strspn.c" 3 7 46#
  "expl:Function strspn, safety" =
  fun
   (s_1_0 : (pointer voidP)) (accept : (pointer voidP))
   (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_accept_6_alloc_table : (alloc_table voidP))
   (voidP_accept_6_tag_table : (tag_table voidP)) (voidP_s_1_5_tag_table :
   (tag_table voidP)) (charP_charM_s_1_5 : (memory voidP Int8.t))
   (charP_charM_accept_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_accept_6_alloc_table accept) ->
     (((=) (typeof voidP_accept_6_tag_table accept) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_accept_6_alloc_table accept) i) /\
       ((<) i (offset_max voidP_accept_6_alloc_table accept))) ->
       ((=) (typeof voidP_accept_6_tag_table (shift accept i)) charP_tag)))))
   /\
   (((allocated voidP_s_1_5_alloc_table s_1_0) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1_0) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1_0))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1_0 i)) charP_tag)))))
   /\
   (#"strspn.jc" 120 12 92#
   ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 13 10 22#
    (valid_str s_1_0 voidP_s_1_5_alloc_table charP_charM_s_1_5))
   /\
   (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 14 13 30#
   (valid_str accept voidP_accept_6_alloc_table charP_charM_accept_6)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint64.any_  () ) in
   try
    begin
    (); ();
     (let p_4 = ref (any_pointer  () : (pointer voidP)) in
     (let a = ref (any_pointer  () : (pointer voidP)) in
     (let count = ref (Safe_uint64.any_  () ) in
     (let __retres = ref (Safe_uint64.any_  () ) in
     try
      begin
      try
       begin
       (count :=
        (let _jessie_41 =
        (#"strspn.jc" 300 24 37# "expl:Integer cast"
        (Safe_uint64.of_int (0))) in
        begin
        (assert {
        (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 7 4 10#
        "expl:Pointer index bounds" true) }); _jessie_41 end));
        begin
        (p_4 :=
         (let _jessie_35 = s_1_0 in
         begin
         (assert {
         (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 9 14#
         "expl:Pointer index bounds" true) }); _jessie_35 end));
         'Loop_7:
         loop
         invariant { (#"strspn.jc" 303 6 4801# true) }
           variant {
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 15 21 40#
             (Int.(-) (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))
             (sub_pointer !p_4 s_1_0))) }
          begin
          any unit
          requires { true } reads { accept, s_1_0 }
          ensures {
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 12 23 143#
             (forall z : (pointer voidP).
              (((same_block s_1_0 z) /\
               (((<=) (sub_pointer s_1_0 z) (0)) /\
               ((same_block z !p_4) /\ ((<) (sub_pointer z !p_4) (0))))) ->
               (exists t_0 : (pointer voidP).
                ((same_block accept t_0) /\
                (((<=) (sub_pointer accept t_0) (0)) /\
                ((same_block t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 z)
                (select charP_charM_accept_6 t_0))))))))))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 11 23 37#
             ((=) (Uint64.to_int !count) (sub_pointer !p_4 s_1_0)))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 33#
              ((<=) (0) (Uint64.to_int !count)))
             /\
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 28 46#
             (Uint64.(<=) !count (strlen s_1_0 charP_charM_s_1_5))))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             (same_block s_1_0 !p_4))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             ((<=) (sub_pointer s_1_0 !p_4) (0)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
             (same_block !p_4
             (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
            ((<=)
            (sub_pointer !p_4
            (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
            (0))))))))))))) } ;
           try
            begin
            begin
            (if
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 26#
            (Safe_int32.(<>) 
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 18#
             "expl:Integer cast"
             (Safe_int32_of_Safe_int8.cast 
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 18#
              "expl:Pointer dereference"
              (acc  voidP_s_1_5_alloc_table charP_charM_s_1_5 !p_4 )) ))
             (#"strspn.jc" 341 27 39# "expl:Integer cast"
             (Safe_int32.of_int (0))) )) then ()
            else (raise (Goto_while_0_break_exc ())));
             try
              begin
              (a :=
               (let _jessie_36 = accept in
               begin
               (assert {
               (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 13 23#
               "expl:Pointer index bounds" true) }); _jessie_36 end));
               'Loop_8:
               loop
               invariant { (#"strspn.jc" 346 15 2057# true) }
                 variant {
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 21 21 50#
                   (Int.(-)
                   (Uint64.to_int (strlen accept charP_charM_accept_6))
                   (sub_pointer !a accept))) }
                begin
                any unit
                requires { true } reads { accept }
                ensures {
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 20 23 68#
                   (forall t : (pointer voidP).
                    (((same_block accept t) /\
                     (((<=) (sub_pointer accept t) (0)) /\
                     ((same_block t !a) /\ ((<) (sub_pointer t !a) (0))))) ->
                     (Int8.(<>) (select charP_charM_s_1_5 !p_4)
                     (select charP_charM_accept_6 t)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   (same_block accept !a))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   ((<=) (sub_pointer accept !a) (0)))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                   (same_block !a
                   (shift accept
                   (Uint64.to_int (strlen accept charP_charM_accept_6)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                  ((<=)
                  (sub_pointer !a
                  (shift accept
                  (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))))
                  } ;
                 try
                  begin
                  begin
                  (if
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 35#
                  (Safe_int32.(<>) 
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 27#
                   "expl:Integer cast"
                   (Safe_int32_of_Safe_int8.cast 
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 27#
                    "expl:Pointer dereference"
                    (acc  voidP_accept_6_alloc_table charP_charM_accept_6 !a
                     )) ))
                   (#"strspn.jc" 372 36 48# "expl:Integer cast"
                   (Safe_int32.of_int (0))) )) then ()
                  else (raise (Goto_while_1_break_exc ())));
                   (if
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 24#
                   (Safe_int32.(=) 
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 18#
                    "expl:Integer cast"
                    (Safe_int32_of_Safe_int8.cast 
                     (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 18#
                     "expl:Pointer dereference"
                     (acc  voidP_s_1_5_alloc_table charP_charM_s_1_5 !p_4 ))
                     ))
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 22 24#
                    "expl:Integer cast"
                    (Safe_int32_of_Safe_int8.cast 
                     (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 22 24#
                     "expl:Pointer dereference"
                     (acc  voidP_accept_6_alloc_table charP_charM_accept_6 !a
                      )) )) )) then (raise (Goto_while_1_break_exc ()))
                   else ());
                   (a :=
                    (let _jessie_37 =
                    (shift_typesafe  !a
                     (Safe_int32.to_int 
                      (#"strspn.jc" 379 49 61# "expl:Integer cast"
                      (Safe_int32.of_int (1))) ) ) in
                    begin
                    (assert {
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 37 40#
                    "expl:Pointer index bounds" true) }); _jessie_37 end))
                  end; (raise (Loop_continue_exc ())) end with
                  Loop_continue_exc _jessie_5 -> () end end end;
               (raise (Goto_while_1_break_exc ())) end with
              Goto_while_1_break_exc _jessie_1 ->
              'While_1_break:
              'While_1_break:
              begin
              ();
               (if
               (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 22#
               (Safe_int32.(=) 
                (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 14#
                "expl:Integer cast"
                (Safe_int32_of_Safe_int8.cast 
                 (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 14#
                 "expl:Pointer dereference"
                 (acc  voidP_accept_6_alloc_table charP_charM_accept_6 !a ))
                 ))
                (#"strspn.jc" 384 30 42# "expl:Integer cast"
                (Safe_int32.of_int (0))) ))
               then
                begin
                (__retres :=
                 (let _jessie_38 = !count in
                 begin
                 (assert {
                 (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 32 12 25#
                 "expl:Pointer index bounds" true) }); _jessie_38 end));
                 (raise (Return_label_exc ())) end else ());
               (count :=
                (let _jessie_39 =
                (Safe_uint64.(+)  !count
                 (#"strspn.jc" 389 61 74# "expl:Integer cast"
                 (Safe_uint64.of_int (1))) ) in
                begin
                (assert {
                (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 33 8 15#
                "expl:Pointer index bounds" true) }); _jessie_39 end)) end
              end;
             (p_4 :=
              (let _jessie_40 =
              (shift_typesafe  !p_4
               (Safe_int32.to_int 
                (#"strspn.jc" 391 40 52# "expl:Integer cast"
                (Safe_int32.of_int (1))) ) ) in
              begin
              (assert {
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 28 31#
              "expl:Pointer index bounds" true) }); _jessie_40 end)) end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_7 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_2 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (let _jessie_42 = !count in
         begin
         (assert {
         (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 35 4 17#
         "expl:Pointer index bounds" true) }); _jessie_42 end)) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_3 ->
      'Return_label:
      'Return_label:
      begin
      (return :=
       (let _jessie_43 = !__retres in
       begin
       (assert { (#"strspn.jc" 397 7 22# "expl:Pointer index bounds" true) });
        _jessie_43 end)); (raise Return) end end)))); absurd  end with Return
    -> !return end)
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Function_strspn_behaviors

  use Unsafe_uint64 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strspn_ensures_default
  #"/Users/macbook/Documents/HSE/verker-master/strspn.c" 3 7 46#
  "expl:Function strspn, default behavior" =
  fun
   (s_1_0 : (pointer voidP)) (accept : (pointer voidP))
   (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_accept_6_alloc_table : (alloc_table voidP))
   (voidP_accept_6_tag_table : (tag_table voidP)) (voidP_s_1_5_tag_table :
   (tag_table voidP)) (charP_charM_s_1_5 : (memory voidP Int8.t))
   (charP_charM_accept_6 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_accept_6_alloc_table accept) ->
     (((=) (typeof voidP_accept_6_tag_table accept) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_accept_6_alloc_table accept) i) /\
       ((<) i (offset_max voidP_accept_6_alloc_table accept))) ->
       ((=) (typeof voidP_accept_6_tag_table (shift accept i)) charP_tag)))))
   /\
   (((allocated voidP_s_1_5_alloc_table s_1_0) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1_0) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1_0))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1_0 i)) charP_tag)))))
   /\
   (#"strspn.jc" 120 12 92#
   ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 13 10 22#
    (valid_str s_1_0 voidP_s_1_5_alloc_table charP_charM_s_1_5))
   /\
   (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 14 13 30#
   (valid_str accept voidP_accept_6_alloc_table charP_charM_accept_6)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
     "expl:Ensures clause"
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
     "expl:Ensures clause"
     ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 24#
      "expl:Ensures clause" ((<=) (0) (Uint64.to_int result)))
     /\
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
     "expl:Ensures clause"
     ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 17 37#
      "expl:Ensures clause"
      (Uint64.(<=) result (strlen s_1_0 charP_charM_s_1_5)))
     /\
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 17 12 143#
     "expl:Ensures clause"
     (forall p_1 : (pointer voidP).
      (forall t_4 : (pointer voidP).
       (((same_block s_1_0 p_1) /\
        (((<=) (sub_pointer s_1_0 p_1) (0)) /\
        ((same_block p_1 (shift s_1_0 (Uint64.to_int result))) /\
        (((<) (sub_pointer p_1 (shift s_1_0 (Uint64.to_int result))) (0)) /\
        ((same_block accept t_4) /\
        (((<=) (sub_pointer accept t_4) (0)) /\
        ((same_block t_4
         (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
        /\
        ((<)
        (sub_pointer t_4
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
        (0))))))))) ->
        (Int8.(<>) (select charP_charM_s_1_5 p_1)
        (select charP_charM_accept_6 t_4)))))))))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (check {
    (#"strspn.jc" 190 10 3429# "expl:Behavior disjointness check"
    (not
    ((exists p_0_0 : (pointer voidP).
      (exists t_2_0 : (pointer voidP).
       ((same_block s_1_0 p_0_0) /\
       (((<=) (sub_pointer s_1_0 p_0_0) (0)) /\
       ((same_block p_0_0
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
       /\
       (((<)
        (sub_pointer p_0_0
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
       /\
       ((same_block accept t_2_0) /\
       (((<=) (sub_pointer accept t_2_0) (0)) /\
       ((same_block t_2_0
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       /\
       (((<)
        (sub_pointer t_2_0
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
        (0))
       /\
       (Int8.(=) (select charP_charM_s_1_5 p_0_0)
       (select charP_charM_accept_6 t_2_0))))))))))))
    /\
    (forall p_2 : (pointer voidP).
     (forall t_1_0 : (pointer voidP).
      (((same_block s_1_0 p_2) /\
       (((<=) (sub_pointer s_1_0 p_2) (0)) /\
       ((same_block p_2
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
       /\
       (((<)
        (sub_pointer p_2
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
       /\
       ((same_block accept t_1_0) /\
       (((<=) (sub_pointer accept t_1_0) (0)) /\
       ((same_block t_1_0
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       /\
       ((<)
       (sub_pointer t_1_0
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       (0))))))))) ->
       (Int8.(<>) (select charP_charM_s_1_5 p_2)
       (select charP_charM_accept_6 t_1_0)))))))) });
     (check {
     (#"strspn.jc" 241 10 3278# "expl:Behavior completeness check"
     ((forall p_3 : (pointer voidP).
       (forall t_1_1 : (pointer voidP).
        (((same_block s_1_0 p_3) /\
         (((<=) (sub_pointer s_1_0 p_3) (0)) /\
         ((same_block p_3
          (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
         /\
         (((<)
          (sub_pointer p_3
          (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
          (0))
         /\
         ((same_block accept t_1_1) /\
         (((<=) (sub_pointer accept t_1_1) (0)) /\
         ((same_block t_1_1
          (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
         /\
         ((<)
         (sub_pointer t_1_1
         (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
         (0))))))))) ->
         (Int8.(<>) (select charP_charM_s_1_5 p_3)
         (select charP_charM_accept_6 t_1_1)))))
     \/
     (exists p_0_1 : (pointer voidP).
      (exists t_2_1 : (pointer voidP).
       ((same_block s_1_0 p_0_1) /\
       (((<=) (sub_pointer s_1_0 p_0_1) (0)) /\
       ((same_block p_0_1
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
       /\
       (((<)
        (sub_pointer p_0_1
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
       /\
       ((same_block accept t_2_1) /\
       (((<=) (sub_pointer accept t_2_1) (0)) /\
       ((same_block t_2_1
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       /\
       (((<)
        (sub_pointer t_2_1
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
        (0))
       /\
       (Int8.(=) (select charP_charM_s_1_5 p_0_1)
       (select charP_charM_accept_6 t_2_1)))))))))))))) });
     (let p_4 = ref (any_pointer  () : (pointer voidP)) in
     (let a = ref (any_pointer  () : (pointer voidP)) in
     (let count = ref (Unsafe_uint64.any_  () ) in
     (let __retres = ref (Unsafe_uint64.any_  () ) in
     try
      begin
      try
       begin
       (count :=
        (#"strspn.jc" 300 24 37# "expl:Integer cast"
        (Unsafe_uint64.of_int (0))));
        begin
        (p_4 := s_1_0);
         'Loop_1:
         loop
         invariant
           { ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
              ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
               (same_block s_1_0 !p_4))
              /\
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
              ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
               ((<=) (sub_pointer s_1_0 !p_4) (0)))
              /\
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
              ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
               (same_block !p_4
               (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))))
              /\
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
              ((<=)
              (sub_pointer !p_4
              (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
              (0))))))))))
             &&
             ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
              ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 33#
               ((<=) (0) (Uint64.to_int !count)))
              /\
              (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 28 46#
              (Uint64.(<=) !count (strlen s_1_0 charP_charM_s_1_5))))))
             &&
             ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 11 23 37#
              ((=) (Uint64.to_int !count) (sub_pointer !p_4 s_1_0)))
             &&
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 12 23 143#
             (forall z : (pointer voidP).
              (((same_block s_1_0 z) /\
               (((<=) (sub_pointer s_1_0 z) (0)) /\
               ((same_block z !p_4) /\ ((<) (sub_pointer z !p_4) (0))))) ->
               (exists t_0 : (pointer voidP).
                ((same_block accept t_0) /\
                (((<=) (sub_pointer accept t_0) (0)) /\
                ((same_block t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 z)
                (select charP_charM_accept_6 t_0))))))))))))) } 
          begin
          any unit requires { true } ensures { true } ;
           try
            begin
            begin
            (if
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 26#
            (Unsafe_int32.(<>) 
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 18#
             "expl:Integer cast"
             (Unsafe_int32_of_Unsafe_int8.cast 
              (acc  charP_charM_s_1_5 !p_4 ) ))
             (#"strspn.jc" 341 27 39# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) )) then ()
            else (raise (Goto_while_0_break_exc ())));
             try
              begin
              (a := accept);
               'Loop_2:
               loop
               invariant
                 { ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                    ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                     (same_block accept !a))
                    /\
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                    ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                     ((<=) (sub_pointer accept !a) (0)))
                    /\
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                    ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                     (same_block !a
                     (shift accept
                     (Uint64.to_int (strlen accept charP_charM_accept_6)))))
                    /\
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                    ((<=)
                    (sub_pointer !a
                    (shift accept
                    (Uint64.to_int (strlen accept charP_charM_accept_6))))
                    (0))))))))))
                   &&
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 20 23 68#
                   (forall t : (pointer voidP).
                    (((same_block accept t) /\
                     (((<=) (sub_pointer accept t) (0)) /\
                     ((same_block t !a) /\ ((<) (sub_pointer t !a) (0))))) ->
                     (Int8.(<>) (select charP_charM_s_1_5 !p_4)
                     (select charP_charM_accept_6 t)))))) } 
                begin
                any unit requires { true } ensures { true } ;
                 try
                  begin
                  begin
                  (if
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 35#
                  (Unsafe_int32.(<>) 
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 27#
                   "expl:Integer cast"
                   (Unsafe_int32_of_Unsafe_int8.cast 
                    (acc  charP_charM_accept_6 !a ) ))
                   (#"strspn.jc" 372 36 48# "expl:Integer cast"
                   (Unsafe_int32.of_int (0))) )) then ()
                  else (raise (Goto_while_1_break_exc ())));
                   (if
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 24#
                   (Unsafe_int32.(=) 
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 18#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_s_1_5 !p_4 ) ))
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 22 24#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_accept_6 !a ) )) ))
                   then (raise (Goto_while_1_break_exc ())) else ());
                   (a :=
                    (shift_  !a
                     (Unsafe_int32.to_int 
                      (#"strspn.jc" 379 49 61# "expl:Integer cast"
                      (Unsafe_int32.of_int (1))) ) )) end;
                   (raise (Loop_continue_exc ())) end with Loop_continue_exc
                  _jessie_5 -> () end end end;
               (raise (Goto_while_1_break_exc ())) end with
              Goto_while_1_break_exc _jessie_1 ->
              'While_1_break:
              'While_1_break:
              begin
              ();
               (if
               (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 22#
               (Unsafe_int32.(=) 
                (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 14#
                "expl:Integer cast"
                (Unsafe_int32_of_Unsafe_int8.cast 
                 (acc  charP_charM_accept_6 !a ) ))
                (#"strspn.jc" 384 30 42# "expl:Integer cast"
                (Unsafe_int32.of_int (0))) ))
               then
                begin (__retres := !count); (raise (Return_label_exc ())) end
               else ());
               (count :=
                (Unsafe_uint64.(+)  !count
                 (#"strspn.jc" 389 61 74# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) )) end end;
             (p_4 :=
              (shift_  !p_4
               (Unsafe_int32.to_int 
                (#"strspn.jc" 391 40 52# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )) end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_7 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_2 ->
       'While_0_break: 'While_0_break: begin (); (__retres := !count) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_3 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let strspn_ensures_exists
  #"/Users/macbook/Documents/HSE/verker-master/strspn.c" 3 7 46#
  "expl:Function strspn, behavior exists" =
  fun
   (s_1_0 : (pointer voidP)) (accept : (pointer voidP))
   (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_accept_6_alloc_table : (alloc_table voidP))
   (voidP_accept_6_tag_table : (tag_table voidP)) (voidP_s_1_5_tag_table :
   (tag_table voidP)) (charP_charM_s_1_5 : (memory voidP Int8.t))
   (charP_charM_accept_6 : (memory voidP Int8.t)) 
   requires {
   ((exists p_0 : (pointer voidP).
     (exists t_2 : (pointer voidP).
      ((same_block s_1_0 p_0) /\
      (((<=) (sub_pointer s_1_0 p_0) (0)) /\
      ((same_block p_0
       (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
      /\
      (((<)
       (sub_pointer p_0
       (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
      /\
      ((same_block accept t_2) /\
      (((<=) (sub_pointer accept t_2) (0)) /\
      ((same_block t_2
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
      /\
      (((<)
       (sub_pointer t_2
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       (0))
      /\
      (Int8.(=) (select charP_charM_s_1_5 p_0)
      (select charP_charM_accept_6 t_2))))))))))))
   /\
   (((allocated voidP_accept_6_alloc_table accept) ->
     (((=) (typeof voidP_accept_6_tag_table accept) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_accept_6_alloc_table accept) i) /\
       ((<) i (offset_max voidP_accept_6_alloc_table accept))) ->
       ((=) (typeof voidP_accept_6_tag_table (shift accept i)) charP_tag)))))
   /\
   (((allocated voidP_s_1_5_alloc_table s_1_0) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1_0) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1_0))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1_0 i)) charP_tag)))))
   /\
   (#"strspn.jc" 120 12 92#
   ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 13 10 22#
    (valid_str s_1_0 voidP_s_1_5_alloc_table charP_charM_s_1_5))
   /\
   (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 14 13 30#
   (valid_str accept voidP_accept_6_alloc_table charP_charM_accept_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 26 15 89#
     "expl:Ensures clause"
     (exists t_3 : (pointer voidP).
      ((same_block accept t_3) /\
      (((<=) (sub_pointer accept t_3) (0)) /\
      ((same_block t_3
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
      /\
      (((<)
       (sub_pointer t_3
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       (0))
      /\
      (Int8.(=)
      (select charP_charM_s_1_5 (shift s_1_0 (Uint64.to_int result)))
      (select charP_charM_accept_6 t_3))))))))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (); ();
     (let p_4 = ref (any_pointer  () : (pointer voidP)) in
     (let a = ref (any_pointer  () : (pointer voidP)) in
     (let count = ref (Unsafe_uint64.any_  () ) in
     (let __retres = ref (Unsafe_uint64.any_  () ) in
     try
      begin
      try
       begin
       (count :=
        (#"strspn.jc" 300 24 37# "expl:Integer cast"
        (Unsafe_uint64.of_int (0))));
        begin
        (p_4 := s_1_0);
         'Loop_3:
         loop
         invariant { (#"strspn.jc" 303 6 4801# true) } 
          begin
          any unit
          requires { true } reads { accept, s_1_0 }
          ensures {
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 12 23 143#
             (forall z : (pointer voidP).
              (((same_block s_1_0 z) /\
               (((<=) (sub_pointer s_1_0 z) (0)) /\
               ((same_block z !p_4) /\ ((<) (sub_pointer z !p_4) (0))))) ->
               (exists t_0 : (pointer voidP).
                ((same_block accept t_0) /\
                (((<=) (sub_pointer accept t_0) (0)) /\
                ((same_block t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 z)
                (select charP_charM_accept_6 t_0))))))))))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 11 23 37#
             ((=) (Uint64.to_int !count) (sub_pointer !p_4 s_1_0)))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 33#
              ((<=) (0) (Uint64.to_int !count)))
             /\
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 28 46#
             (Uint64.(<=) !count (strlen s_1_0 charP_charM_s_1_5))))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             (same_block s_1_0 !p_4))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             ((<=) (sub_pointer s_1_0 !p_4) (0)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
             (same_block !p_4
             (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
            ((<=)
            (sub_pointer !p_4
            (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
            (0))))))))))))) } ;
           try
            begin
            begin
            (if
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 26#
            (Unsafe_int32.(<>) 
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 18#
             "expl:Integer cast"
             (Unsafe_int32_of_Unsafe_int8.cast 
              (acc  charP_charM_s_1_5 !p_4 ) ))
             (#"strspn.jc" 341 27 39# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) )) then ()
            else (raise (Goto_while_0_break_exc ())));
             try
              begin
              (a := accept);
               'Loop_4:
               loop
               invariant { (#"strspn.jc" 346 15 2057# true) } 
                begin
                any unit
                requires { true } reads { accept }
                ensures {
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 20 23 68#
                   (forall t : (pointer voidP).
                    (((same_block accept t) /\
                     (((<=) (sub_pointer accept t) (0)) /\
                     ((same_block t !a) /\ ((<) (sub_pointer t !a) (0))))) ->
                     (Int8.(<>) (select charP_charM_s_1_5 !p_4)
                     (select charP_charM_accept_6 t)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   (same_block accept !a))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   ((<=) (sub_pointer accept !a) (0)))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                   (same_block !a
                   (shift accept
                   (Uint64.to_int (strlen accept charP_charM_accept_6)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                  ((<=)
                  (sub_pointer !a
                  (shift accept
                  (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))))
                  } ;
                 try
                  begin
                  begin
                  (if
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 35#
                  (Unsafe_int32.(<>) 
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 27#
                   "expl:Integer cast"
                   (Unsafe_int32_of_Unsafe_int8.cast 
                    (acc  charP_charM_accept_6 !a ) ))
                   (#"strspn.jc" 372 36 48# "expl:Integer cast"
                   (Unsafe_int32.of_int (0))) )) then ()
                  else (raise (Goto_while_1_break_exc ())));
                   (if
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 24#
                   (Unsafe_int32.(=) 
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 18#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_s_1_5 !p_4 ) ))
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 22 24#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_accept_6 !a ) )) ))
                   then (raise (Goto_while_1_break_exc ())) else ());
                   (a :=
                    (shift_  !a
                     (Unsafe_int32.to_int 
                      (#"strspn.jc" 379 49 61# "expl:Integer cast"
                      (Unsafe_int32.of_int (1))) ) )) end;
                   (raise (Loop_continue_exc ())) end with Loop_continue_exc
                  _jessie_5 -> () end end end;
               (raise (Goto_while_1_break_exc ())) end with
              Goto_while_1_break_exc _jessie_1 ->
              'While_1_break:
              'While_1_break:
              begin
              ();
               (if
               (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 22#
               (Unsafe_int32.(=) 
                (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 14#
                "expl:Integer cast"
                (Unsafe_int32_of_Unsafe_int8.cast 
                 (acc  charP_charM_accept_6 !a ) ))
                (#"strspn.jc" 384 30 42# "expl:Integer cast"
                (Unsafe_int32.of_int (0))) ))
               then
                begin (__retres := !count); (raise (Return_label_exc ())) end
               else ());
               (count :=
                (Unsafe_uint64.(+)  !count
                 (#"strspn.jc" 389 61 74# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) )) end end;
             (p_4 :=
              (shift_  !p_4
               (Unsafe_int32.to_int 
                (#"strspn.jc" 391 40 52# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )) end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_7 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_2 ->
       'While_0_break: 'While_0_break: begin (); (__retres := !count) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_3 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let strspn_ensures_not_exists
  #"/Users/macbook/Documents/HSE/verker-master/strspn.c" 3 7 46#
  "expl:Function strspn, behavior not_exists" =
  fun
   (s_1_0 : (pointer voidP)) (accept : (pointer voidP))
   (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_accept_6_alloc_table : (alloc_table voidP))
   (voidP_accept_6_tag_table : (tag_table voidP)) (voidP_s_1_5_tag_table :
   (tag_table voidP)) (charP_charM_s_1_5 : (memory voidP Int8.t))
   (charP_charM_accept_6 : (memory voidP Int8.t)) 
   requires {
   ((forall p : (pointer voidP).
     (forall t_1 : (pointer voidP).
      (((same_block s_1_0 p) /\
       (((<=) (sub_pointer s_1_0 p) (0)) /\
       ((same_block p
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
       /\
       (((<)
        (sub_pointer p
        (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
       /\
       ((same_block accept t_1) /\
       (((<=) (sub_pointer accept t_1) (0)) /\
       ((same_block t_1
        (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       /\
       ((<)
       (sub_pointer t_1
       (shift accept (Uint64.to_int (strlen accept charP_charM_accept_6))))
       (0))))))))) ->
       (Int8.(<>) (select charP_charM_s_1_5 p)
       (select charP_charM_accept_6 t_1)))))
   /\
   (((allocated voidP_accept_6_alloc_table accept) ->
     (((=) (typeof voidP_accept_6_tag_table accept) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_accept_6_alloc_table accept) i) /\
       ((<) i (offset_max voidP_accept_6_alloc_table accept))) ->
       ((=) (typeof voidP_accept_6_tag_table (shift accept i)) charP_tag)))))
   /\
   (((allocated voidP_s_1_5_alloc_table s_1_0) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1_0) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1_0))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1_0 i)) charP_tag)))))
   /\
   (#"strspn.jc" 120 12 92#
   ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 13 10 22#
    (valid_str s_1_0 voidP_s_1_5_alloc_table charP_charM_s_1_5))
   /\
   (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 14 13 30#
   (valid_str accept voidP_accept_6_alloc_table charP_charM_accept_6))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 32 15 35#
     "expl:Ensures clause"
     (Uint64.(=) result (strlen s_1_0 charP_charM_s_1_5)))) } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (); ();
     (let p_4 = ref (any_pointer  () : (pointer voidP)) in
     (let a = ref (any_pointer  () : (pointer voidP)) in
     (let count = ref (Unsafe_uint64.any_  () ) in
     (let __retres = ref (Unsafe_uint64.any_  () ) in
     try
      begin
      try
       begin
       (count :=
        (#"strspn.jc" 300 24 37# "expl:Integer cast"
        (Unsafe_uint64.of_int (0))));
        begin
        (p_4 := s_1_0);
         'Loop_5:
         loop
         invariant { (#"strspn.jc" 303 6 4801# true) } 
          begin
          any unit
          requires { true } reads { accept, s_1_0 }
          ensures {
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 12 23 143#
             (forall z : (pointer voidP).
              (((same_block s_1_0 z) /\
               (((<=) (sub_pointer s_1_0 z) (0)) /\
               ((same_block z !p_4) /\ ((<) (sub_pointer z !p_4) (0))))) ->
               (exists t_0 : (pointer voidP).
                ((same_block accept t_0) /\
                (((<=) (sub_pointer accept t_0) (0)) /\
                ((same_block t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_0
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 z)
                (select charP_charM_accept_6 t_0))))))))))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 11 23 37#
             ((=) (Uint64.to_int !count) (sub_pointer !p_4 s_1_0)))
            /\
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 46#
             ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 23 33#
              ((<=) (0) (Uint64.to_int !count)))
             /\
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 10 28 46#
             (Uint64.(<=) !count (strlen s_1_0 charP_charM_s_1_5))))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             (same_block s_1_0 !p_4))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 22#
             ((<=) (sub_pointer s_1_0 !p_4) (0)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 16 39#
            ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
             (same_block !p_4
             (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 9 21 39#
            ((<=)
            (sub_pointer !p_4
            (shift s_1_0 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
            (0))))))))))))) } ;
           try
            begin
            begin
            (if
            (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 26#
            (Unsafe_int32.(<>) 
             (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 17 16 18#
             "expl:Integer cast"
             (Unsafe_int32_of_Unsafe_int8.cast 
              (acc  charP_charM_s_1_5 !p_4 ) ))
             (#"strspn.jc" 341 27 39# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) )) then ()
            else (raise (Goto_while_0_break_exc ())));
             try
              begin
              (a := accept);
               'Loop_6:
               loop
               invariant { (#"strspn.jc" 346 15 2057# true) } 
                begin
                any unit
                requires { true } reads { accept }
                ensures {
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 20 23 68#
                   (forall t : (pointer voidP).
                    (((same_block accept t) /\
                     (((<=) (sub_pointer accept t) (0)) /\
                     ((same_block t !a) /\ ((<) (sub_pointer t !a) (0))))) ->
                     (Int8.(<>) (select charP_charM_s_1_5 !p_4)
                     (select charP_charM_accept_6 t)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   (same_block accept !a))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 27#
                   ((<=) (sub_pointer accept !a) (0)))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 16 54#
                  ((#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                   (same_block !a
                   (shift accept
                   (Uint64.to_int (strlen accept charP_charM_accept_6)))))
                  /\
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 19 26 54#
                  ((<=)
                  (sub_pointer !a
                  (shift accept
                  (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))))
                  } ;
                 try
                  begin
                  begin
                  (if
                  (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 35#
                  (Unsafe_int32.(<>) 
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 23 25 27#
                   "expl:Integer cast"
                   (Unsafe_int32_of_Unsafe_int8.cast 
                    (acc  charP_charM_accept_6 !a ) ))
                   (#"strspn.jc" 372 36 48# "expl:Integer cast"
                   (Unsafe_int32.of_int (0))) )) then ()
                  else (raise (Goto_while_1_break_exc ())));
                   (if
                   (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 24#
                   (Unsafe_int32.(=) 
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 16 18#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_s_1_5 !p_4 ) ))
                    (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 25 22 24#
                    "expl:Integer cast"
                    (Unsafe_int32_of_Unsafe_int8.cast 
                     (acc  charP_charM_accept_6 !a ) )) ))
                   then (raise (Goto_while_1_break_exc ())) else ());
                   (a :=
                    (shift_  !a
                     (Unsafe_int32.to_int 
                      (#"strspn.jc" 379 49 61# "expl:Integer cast"
                      (Unsafe_int32.of_int (1))) ) )) end;
                   (raise (Loop_continue_exc ())) end with Loop_continue_exc
                  _jessie_5 -> () end end end;
               (raise (Goto_while_1_break_exc ())) end with
              Goto_while_1_break_exc _jessie_1 ->
              'While_1_break:
              'While_1_break:
              begin
              ();
               (if
               (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 22#
               (Unsafe_int32.(=) 
                (#"/Users/macbook/Documents/HSE/verker-master/strspn.c" 30 12 14#
                "expl:Integer cast"
                (Unsafe_int32_of_Unsafe_int8.cast 
                 (acc  charP_charM_accept_6 !a ) ))
                (#"strspn.jc" 384 30 42# "expl:Integer cast"
                (Unsafe_int32.of_int (0))) ))
               then
                begin (__retres := !count); (raise (Return_label_exc ())) end
               else ());
               (count :=
                (Unsafe_uint64.(+)  !count
                 (#"strspn.jc" 389 61 74# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) )) end end;
             (p_4 :=
              (shift_  !p_4
               (Unsafe_int32.to_int 
                (#"strspn.jc" 391 40 52# "expl:Integer cast"
                (Unsafe_int32.of_int (1))) ) )) end;
             (raise (Loop_continue_exc ())) end with Loop_continue_exc
            _jessie_7 -> () end end end; (raise (Goto_while_0_break_exc ()))
        end end with Goto_while_0_break_exc _jessie_2 ->
       'While_0_break: 'While_0_break: begin (); (__retres := !count) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_3 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

theory Root_unsigned_charP

  use why3.Bool.Bool 
  
  type unsigned_charP 
  
end

theory Struct_unsigned_charP

  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function unsigned_charP_tag  : (tag_id
  unsigned_charP)
  
  axiom Unsigned_charP_parenttag_bottom :
  (parenttag unsigned_charP_tag bottom_tag)
  
  axiom Unsigned_charP_is_final :
  (forall unsigned_charP_tag_table : (tag_table unsigned_charP).
   (forall p : (pointer unsigned_charP).
    ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) ->
     ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag))))
  
  predicate frame_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_tag_table : (tag_table unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((tag_extends old_unsigned_charP_tag_table unsigned_charP_tag_table) /\
     (alloc_tag_block old_unsigned_charP_tag_table unsigned_charP_tag_table
     p))
  
  predicate frame_free_struct_unsigned_charP (p : (pointer unsigned_charP))
  (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((free_extends old_unsigned_charP_alloc_table unsigned_charP_alloc_table)
     /\
     (free_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p))
  
  predicate frame_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (n : int) (old_unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     ((alloc_extends old_unsigned_charP_alloc_table
      unsigned_charP_alloc_table)
     /\
     (alloc_block old_unsigned_charP_alloc_table unsigned_charP_alloc_table p
     n))
  
  predicate fresh_tag_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (tag_fresh unsigned_charP_tag_table p)
  
  predicate fresh_alloc_struct_unsigned_charP (p : (pointer unsigned_charP))
  (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = (alloc_fresh unsigned_charP_alloc_table p)
  
  predicate container_of_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate container_of_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = true
  
  predicate typeof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = ((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag)
  
  predicate typeof_struct_unsigned_charP (p : (pointer unsigned_charP)) (l :
  int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     (((=) (typeof unsigned_charP_tag_table p) unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof unsigned_charP_tag_table (shift p i)) unsigned_charP_tag))))
  
  predicate instanceof_singleton_struct_unsigned_charP (p : (pointer
  unsigned_charP)) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  = (instanceof unsigned_charP_tag_table p unsigned_charP_tag)
  
  predicate instanceof_struct_unsigned_charP (p : (pointer unsigned_charP))
  (l : int) (r : int) (unsigned_charP_tag_table : (tag_table unsigned_charP))
  =
     ((instanceof unsigned_charP_tag_table p unsigned_charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof unsigned_charP_tag_table (shift p i) unsigned_charP_tag))))
  
  predicate right_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((>=) (offset_max unsigned_charP_alloc_table p) b)
  
  predicate left_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  = ((<=) (offset_min unsigned_charP_alloc_table p) a)
  
  predicate valid_struct_unsigned_charP (p : (pointer unsigned_charP)) (a :
  int) (b : int) (unsigned_charP_alloc_table : (alloc_table unsigned_charP))
  =
     (((<=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((>=) (offset_max unsigned_charP_alloc_table p) b))
  
  predicate strict_valid_struct_unsigned_charP (p : (pointer unsigned_charP))
  (a : int) (b : int) (unsigned_charP_alloc_table : (alloc_table
  unsigned_charP))
  =
     (((=) (offset_min unsigned_charP_alloc_table p) a) /\
     ((=) (offset_max unsigned_charP_alloc_table p) b))
  
  axiom Unsigned_charP_int : ((=) (int_of_tag unsigned_charP_tag) (4))
  
end

module Struct_unsigned_charP_unsafe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !unsigned_charP_alloc_table p)) }
    writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP_requires
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { ((>=) n (0)) } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
end

module Struct_unsigned_charP_safe

  use import Struct_unsigned_charP 
  
  use import Root_unsigned_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_unsigned_charP
  (p : (pointer unsigned_charP)) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) : unit
    requires { true } writes { unsigned_charP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !unsigned_charP_alloc_table (old !unsigned_charP_alloc_table)))
      \/
      ((frame_free_struct_unsigned_charP p (old !unsigned_charP_alloc_table)
       !unsigned_charP_alloc_table)
      /\ (fresh_alloc_struct_unsigned_charP p !unsigned_charP_alloc_table)))
      }
  
  val allocate_struct_unsigned_charP
  (n : int) 
   (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
    (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
     unsigned_charP)
     requires { true } writes { unsigned_charP_alloc_table,
     unsigned_charP_tag_table }
     ensures {
       ((strict_valid_struct_unsigned_charP result (0) (Int.(-) n (1))
        !unsigned_charP_alloc_table)
       /\
       ((frame_alloc_struct_unsigned_charP result n (old
        !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
       /\
       ((frame_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table) !unsigned_charP_tag_table)
       /\
       ((fresh_alloc_struct_unsigned_charP result (old
        !unsigned_charP_alloc_table))
       /\
       ((fresh_tag_struct_unsigned_charP result (old
        !unsigned_charP_tag_table))
       /\
       ((typeof_struct_unsigned_charP result (0) n !unsigned_charP_tag_table)
       /\
       (container_of_struct_unsigned_charP result (0) n
       !unsigned_charP_tag_table))))))) }
  
  val allocate_singleton_struct_unsigned_charP
  (unsigned_charP_alloc_table : ref (alloc_table unsigned_charP)) 
   (unsigned_charP_tag_table : ref (tag_table unsigned_charP)) : (pointer
    unsigned_charP)
    requires { true } writes { unsigned_charP_alloc_table,
    unsigned_charP_tag_table }
    ensures {
      ((strict_valid_struct_unsigned_charP result (0) (0)
       !unsigned_charP_alloc_table)
      /\
      ((frame_alloc_struct_unsigned_charP result (1) (old
       !unsigned_charP_alloc_table) !unsigned_charP_alloc_table)
      /\
      ((frame_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table) !unsigned_charP_tag_table)
      /\
      ((fresh_alloc_struct_unsigned_charP result (old
       !unsigned_charP_alloc_table))
      /\
      ((fresh_tag_struct_unsigned_charP result (old
       !unsigned_charP_tag_table))
      /\
      ((typeof_singleton_struct_unsigned_charP result
       !unsigned_charP_tag_table)
      /\
      (container_of_singleton_struct_unsigned_charP result
      !unsigned_charP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_0_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_0_4 : (memory voidP Int8.t)) : Uint64.t
     requires { true }
     ensures {
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       ((#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_0_4)))
       /\
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       ((#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 71 12 30#
        "expl:Ensures clause"
        ((=)
        (Int8.to_int
        (select charP_charM_s_0_4 (shift s_0 (Uint64.to_int result)))) (0)))
       /\
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 72 12 64#
       "expl:Ensures clause"
       (forall i_6 : int.
        ((((<=) (0) i_6) /\ ((<) i_6 (Uint64.to_int result))) ->
         ((<>) (Int8.to_int (select charP_charM_s_0_4 (shift s_0 i_6))) (0))))))))))
       }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_0_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_0_4 : (memory voidP Int8.t)) : Uint64.t
     requires {
       ("expl:External"
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 68 10 22#
       "expl:Requires clause"
       (valid_str s_0 voidP_s_0_4_alloc_table charP_charM_s_0_4))) }
     ensures {
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       ((#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_0_4)))
       /\
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 70 12 32#
       "expl:Ensures clause"
       ((#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 71 12 30#
        "expl:Ensures clause"
        ((=)
        (Int8.to_int
        (select charP_charM_s_0_4 (shift s_0 (Uint64.to_int result)))) (0)))
       /\
       (#"/Users/macbook/Documents/HSE/verker-master/./strlen.h" 72 12 64#
       "expl:Ensures clause"
       (forall i_6 : int.
        ((((<=) (0) i_6) /\ ((<) i_6 (Uint64.to_int result))) ->
         ((<>) (Int8.to_int (select charP_charM_s_0_4 (shift s_0 i_6))) (0))))))))))
       }
  
end

module Function_strspn

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strspn
  (s_1_0 : (pointer voidP)) 
   (accept : (pointer voidP)) 
    (voidP_accept_6_alloc_table : (alloc_table voidP)) 
     (voidP_s_1_5_alloc_table : (alloc_table voidP)) 
      (voidP_accept_6_tag_table : (tag_table voidP)) 
       (voidP_s_1_5_tag_table : (tag_table voidP)) 
        (charP_charM_accept_6 : (memory voidP Int8.t)) 
         (charP_charM_s_1_5 : (memory voidP Int8.t)) : Uint64.t
          requires { true }
          ensures {
            (((forall p : (pointer voidP).
               (forall t_1 : (pointer voidP).
                (((same_block s_1_0 p) /\
                 (((<=) (sub_pointer s_1_0 p) (0)) /\
                 ((same_block p
                  (shift s_1_0
                  (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
                 /\
                 (((<)
                  (sub_pointer p
                  (shift s_1_0
                  (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
                 /\
                 ((same_block accept t_1) /\
                 (((<=) (sub_pointer accept t_1) (0)) /\
                 ((same_block t_1
                  (shift accept
                  (Uint64.to_int (strlen accept charP_charM_accept_6))))
                 /\
                 ((<)
                 (sub_pointer t_1
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))
                 ->
                 (Int8.(<>) (select charP_charM_s_1_5 p)
                 (select charP_charM_accept_6 t_1))))) ->
              (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 32 15 35#
              "expl:Ensures clause"
              (Uint64.(=) result (strlen s_1_0 charP_charM_s_1_5))))
            /\
            (((exists p_0 : (pointer voidP).
               (exists t_2 : (pointer voidP).
                ((same_block s_1_0 p_0) /\
                (((<=) (sub_pointer s_1_0 p_0) (0)) /\
                ((same_block p_0
                 (shift s_1_0
                 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
                /\
                (((<)
                 (sub_pointer p_0
                 (shift s_1_0
                 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
                /\
                ((same_block accept t_2) /\
                (((<=) (sub_pointer accept t_2) (0)) /\
                ((same_block t_2
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_2
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 p_0)
                (select charP_charM_accept_6 t_2)))))))))))) ->
              (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 26 15 89#
              "expl:Ensures clause"
              (exists t_3 : (pointer voidP).
               ((same_block accept t_3) /\
               (((<=) (sub_pointer accept t_3) (0)) /\
               ((same_block t_3
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6))))
               /\
               (((<)
                (sub_pointer t_3
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
               /\
               (Int8.(=)
               (select charP_charM_s_1_5
               (shift s_1_0 (Uint64.to_int result)))
               (select charP_charM_accept_6 t_3)))))))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 24#
             "expl:Ensures clause" ((<=) (0) (Uint64.to_int result)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 17 37#
             "expl:Ensures clause"
             (Uint64.(<=) result (strlen s_1_0 charP_charM_s_1_5)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 17 12 143#
            "expl:Ensures clause"
            (forall p_1 : (pointer voidP).
             (forall t_4 : (pointer voidP).
              (((same_block s_1_0 p_1) /\
               (((<=) (sub_pointer s_1_0 p_1) (0)) /\
               ((same_block p_1 (shift s_1_0 (Uint64.to_int result))) /\
               (((<) (sub_pointer p_1 (shift s_1_0 (Uint64.to_int result)))
                (0))
               /\
               ((same_block accept t_4) /\
               (((<=) (sub_pointer accept t_4) (0)) /\
               ((same_block t_4
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6))))
               /\
               ((<)
               (sub_pointer t_4
               (shift accept
               (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))
               ->
               (Int8.(<>) (select charP_charM_s_1_5 p_1)
               (select charP_charM_accept_6 t_4))))))))))))) }
  
end

module Function_strspn_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strspn
  (s_1_0 : (pointer voidP)) 
   (accept : (pointer voidP)) 
    (voidP_accept_6_alloc_table : (alloc_table voidP)) 
     (voidP_s_1_5_alloc_table : (alloc_table voidP)) 
      (voidP_accept_6_tag_table : (tag_table voidP)) 
       (voidP_s_1_5_tag_table : (tag_table voidP)) 
        (charP_charM_accept_6 : (memory voidP Int8.t)) 
         (charP_charM_s_1_5 : (memory voidP Int8.t)) : Uint64.t
          requires {
            ("expl:Internal"
            (#"strspn.jc" 120 12 92# "expl:Requires clause"
            ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 13 10 22#
             "expl:Requires clause"
             (valid_str s_1_0 voidP_s_1_5_alloc_table charP_charM_s_1_5))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 14 13 30#
            "expl:Requires clause"
            (valid_str accept voidP_accept_6_alloc_table
            charP_charM_accept_6))))) }
          ensures {
            (((forall p : (pointer voidP).
               (forall t_1 : (pointer voidP).
                (((same_block s_1_0 p) /\
                 (((<=) (sub_pointer s_1_0 p) (0)) /\
                 ((same_block p
                  (shift s_1_0
                  (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
                 /\
                 (((<)
                  (sub_pointer p
                  (shift s_1_0
                  (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
                 /\
                 ((same_block accept t_1) /\
                 (((<=) (sub_pointer accept t_1) (0)) /\
                 ((same_block t_1
                  (shift accept
                  (Uint64.to_int (strlen accept charP_charM_accept_6))))
                 /\
                 ((<)
                 (sub_pointer t_1
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))
                 ->
                 (Int8.(<>) (select charP_charM_s_1_5 p)
                 (select charP_charM_accept_6 t_1))))) ->
              (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 32 15 35#
              "expl:Ensures clause"
              (Uint64.(=) result (strlen s_1_0 charP_charM_s_1_5))))
            /\
            (((exists p_0 : (pointer voidP).
               (exists t_2 : (pointer voidP).
                ((same_block s_1_0 p_0) /\
                (((<=) (sub_pointer s_1_0 p_0) (0)) /\
                ((same_block p_0
                 (shift s_1_0
                 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5))))
                /\
                (((<)
                 (sub_pointer p_0
                 (shift s_1_0
                 (Uint64.to_int (strlen s_1_0 charP_charM_s_1_5)))) (0))
                /\
                ((same_block accept t_2) /\
                (((<=) (sub_pointer accept t_2) (0)) /\
                ((same_block t_2
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6))))
                /\
                (((<)
                 (sub_pointer t_2
                 (shift accept
                 (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
                /\
                (Int8.(=) (select charP_charM_s_1_5 p_0)
                (select charP_charM_accept_6 t_2)))))))))))) ->
              (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 26 15 89#
              "expl:Ensures clause"
              (exists t_3 : (pointer voidP).
               ((same_block accept t_3) /\
               (((<=) (sub_pointer accept t_3) (0)) /\
               ((same_block t_3
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6))))
               /\
               (((<)
                (sub_pointer t_3
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0))
               /\
               (Int8.(=)
               (select charP_charM_s_1_5
               (shift s_1_0 (Uint64.to_int result)))
               (select charP_charM_accept_6 t_3)))))))))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 24#
             "expl:Ensures clause" ((<=) (0) (Uint64.to_int result)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 12 37#
            "expl:Ensures clause"
            ((#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 16 17 37#
             "expl:Ensures clause"
             (Uint64.(<=) result (strlen s_1_0 charP_charM_s_1_5)))
            /\
            (#"/Users/macbook/Documents/HSE/verker-master/./strspn.h" 17 12 143#
            "expl:Ensures clause"
            (forall p_1 : (pointer voidP).
             (forall t_4 : (pointer voidP).
              (((same_block s_1_0 p_1) /\
               (((<=) (sub_pointer s_1_0 p_1) (0)) /\
               ((same_block p_1 (shift s_1_0 (Uint64.to_int result))) /\
               (((<) (sub_pointer p_1 (shift s_1_0 (Uint64.to_int result)))
                (0))
               /\
               ((same_block accept t_4) /\
               (((<=) (sub_pointer accept t_4) (0)) /\
               ((same_block t_4
                (shift accept
                (Uint64.to_int (strlen accept charP_charM_accept_6))))
               /\
               ((<)
               (sub_pointer t_4
               (shift accept
               (Uint64.to_int (strlen accept charP_charM_accept_6)))) (0)))))))))
               ->
               (Int8.(<>) (select charP_charM_s_1_5 p_1)
               (select charP_charM_accept_6 t_4))))))))))))) }
  
end
